#!/usr/bin/env python

import json
import argparse
import os
import yaml
from collections import defaultdict
from common.Function import Function

TABLE_HEADER = "YEP_USE_DISPATCH_TABLE_SECTION const FunctionDescriptor<YepStatus (YEPABI*)(%s YEP_RESTRICT, " \
        "%s YEP_RESTRICT, %s YEP_RESTRICT, YepSize)> _dispatchTable_%s[] = {"
IMPLEMENTATION_DESCRIPTION = "YEP_DESCRIBE_FUNCTION_IMPLEMENTATION(%s, %s, %s, %s, %s, \"asm\", YEP_NULL_POINTER, YEP_NULL_POINTER)"
FUNCTION_POINTER_DECLARATION = "YEP_USE_DISPATCH_POINTER_SECTION YepStatus (YEPABI*_{name})({0}) = YEP_NULL_POINTER;"
DISPATCH_STUB = "YEP_USE_DISPATCH_FUNCTION_SECTION YepStatus YEPABI {name}({0}) {{ return _{name}({1}); }}"
f = None

x86_64_SIMD_EXTENSIONS = {
    "Nehalem"       : ["YepX86SimdFeatureSSE", "YepX86SimdFeatureSSE2"],
    "SandyBridge"   : ["YepX86SimdFeatureAVX"],
    "Haswell"       : ["YepX86SimdFeatureAVX2", "YepX86SimdFeatureAVX"]
}

x86_64_SYSTEM_FEATURES = {
    ("Nehalem", "Microsoft")        : ["YepX86SystemFeatureXMM"],
    ("SandyBridge", "Microsoft")    : ["YepX86SystemFeatureYMM"],
    ("Haswell", "Microsoft")        : ["YepX86SystemFeatureYMM"],
    ("Nehalem", "SysV")             : ["YepX86SystemFeatureXMM"],
    ("SandyBridge", "SysV")         : ["YepX86SystemFeatureYMM"],
    ("Haswell", "SysV")             : ["YepX86SystemFeatureYMM"]
}

def write_table_header(func_metadata):
    """
    Writes the dispatch table header to the output file
    :param func_metadata JSON metadata generated by PeachPy during compilation
    """
    arg_type_input = filter(lambda arg: arg["name"] == "xPointer", func_metadata["arguments"])[0]["type"]
    arg_type_output = filter(lambda arg: arg["name"] == "zPointer", func_metadata["arguments"])[0]["type"]
    func_name = func_metadata["name"]
    outfile.write(TABLE_HEADER % (arg_type_input, arg_type_input, arg_type_output, func_name))
    outfile.write('\n')

def write_systemv_abi(func_metadata):
    target_arch = func_metadata["uarch"]
    isa_extensions = "YepIsaFeaturesDefault"
    simd_extensions = x86_64_SIMD_EXTENSIONS[target_arch]
    system_extensions = x86_64_SYSTEM_FEATURES[(target_arch, "SysV")]
    yep_target_arch = "YepCpuMicroarchitecture" + target_arch
    outfile.write('    ')
    outfile.write(IMPLEMENTATION_DESCRIPTION % (func_metadata["symbol"], isa_extensions, \
            ' | '.join(simd_extensions), ' | '.join(system_extensions), yep_target_arch))

def generate_includes(src_dir):
    outfile.write("""
#include <yepPrivate.h>
#include <yepCore.h>
""")
    for dir_path,subdirs,build_files in os.walk(src_dir):
        for build_file in build_files:
            if build_file.endswith(".h"):
                outfile.write("#include <core/%s>\n" % build_file)


def generate_dispatch_for_asm(func, data_list):
    write_table_header(data_list[0])
    for i,data in enumerate(data_list):
        write_systemv_abi(data)
        outfile.write(',\n')
    outfile.write("YEP_DESCRIBE_FUNCTION_IMPLEMENTATION({}, YepIsaFeaturesDefault, YepSimdFeaturesDefault, YepSystemFeaturesDefault, YepCpuMicroarchitectureUnknown, \"c++\", \"Naive\", \"None\")".format(data["symbol"]))
    outfile.write("\n};")
    outfile.write("\n\n")


def generate_dispatch_table_header():
    pre, ext = os.path.splitext(options.output)
    header_out = pre + ".h"
    with open(header_out, "w") as header_outfile:
        header_outfile.write("""
#pragma once

#include <yepPredefines.h>
#include <yepTypes.h>
#include <yepPrivate.h>

""")
        for func in all_functions.values():
            header_outfile.write(func.default_impl_declaration)
            header_outfile.write("\n")
            

        for func in all_functions.values():
            header_outfile.write(func.dispatch_table_declaration)
            header_outfile.write("\n")

        header_outfile.write("\n\n")

        for func in all_functions.values():
            header_outfile.write(func.function_pointer_declaration)
            header_outfile.write("\n")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Generates Dispatch tables for Yeppp")
    parser.add_argument("-o", dest="output", required=True, help="Output File name")
    parser.add_argument("input", nargs="+")
    parser.add_argument("--yaml", dest="specfile")
    options = parser.parse_args()

    outfile = open(options.output, "w")

    # Open the specfile and parse it with the YAML parser
    specfile = open(options.specfile, "r")
    yaml_data = yaml.load(specfile)
    module = yaml_data["module"]
    all_functions = {}
    for op_set in yaml_data["functions"]:
        for func_group in op_set["function_groups"]:
            for func in func_group["group"]:
                # Map function names -> Function objects
                all_functions[func["declaration"].split()[0]] = Function(func, func_group)


    # Put all implementations of a given function specialization in
    # a dictionary indexed by name.  E.g "yepCore_Add_V8sV8s_V8s" ->
    # a list of all implementations of that function's JSON data
    # Parse all JSON files and mark them as having assembly implementations
    json_files = options.input
    decoder = json.JSONDecoder()
    asm_function_dict = defaultdict(list)
    for json_file in json_files:
        with open(json_file) as json_f:
            metadata = decoder.decode(json_f.read())
            for func_data in metadata:
                func_name = func_data["name"]
                asm_function_dict[func_name].append(func_data)
                all_functions[func_name].has_asm_impl = True

    generate_includes("library/sources/" + module) # Write the #include<> at head
    generate_dispatch_table_header()

    # Iterate through the different functions with asm impls, generating their dispatch tables
    for func,data_list in asm_function_dict.items():
        generate_dispatch_for_asm(func, data_list)

    # Iterate through the functions which do not have asm implementations
    for func in all_functions.values():
        if func.has_asm_impl: continue # We already generated these above
        outfile.write("\n")
        outfile.write(func.dispatch_table)
        outfile.write("\n\n")

    # Generate dispatch function pointers
    for func,data_list in asm_function_dict.items():
        data = data_list[0]
        outfile.write(FUNCTION_POINTER_DECLARATION.format(", ".join(arg["type"] for arg in data["arguments"]), **data_list[0]))
        outfile.write("\n")
    outfile.write("\n")

    outfile.write("\n")
    for func in all_functions.values():
        if func.has_asm_impl: continue
        outfile.write("\n")
        outfile.write(func.function_pointer_definition)

    # Write the functions which call the function pointers from dispatch table for asm functions
    outfile.write("\n")
    for func,data_list in asm_function_dict.items():
        data = data_list[0]
        outfile.write(DISPATCH_STUB.format(", ".join(arg["type"] + " " + arg["name"] for arg in data["arguments"]), \
                ", ".join(arg["name"] for arg in data["arguments"]), **data_list[0]))
        outfile.write("\n\n")

    # Write the functions which call function points from dispatch table for non-asm functions
    outfile.write("\n\n")
    for func in all_functions.values():
        if func.has_asm_impl: continue
        outfile.write(func.dispatch_stub)
        outfile.write("\n\n")

